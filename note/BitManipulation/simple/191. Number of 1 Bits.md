### 题目
编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 '1'
的个数（也被称为[汉明重量](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F)）。



**示例 1：**


​    
    输入: 00000000000000000000000000001011
    输出: 3
    解释: 输入的二进制串 **00000000000000000000000000001011**  中，共有三位为 '1'。


**示例 2：**


​    
    输入: 00000000000000000000000010000000
    输出: 1
    解释: 输入的二进制串 **00000000000000000000000010000000**  中，共有一位为 '1'。


**示例 3：**


​    
    输入: 11111111111111111111111111111101
    输出: 31
    解释: 输入的二进制串 **11111111111111111111111111111101** 中，共有 31 位为 '1'。



**提示：**

  * 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
  * 在 Java 中，编译器使用[二进制补码](https://baike.baidu.com/item/二进制补码/5295284)记法来表示有符号整数。因此，在上面的  **示例 3**  中，输入表示有符号整数 `-3`。



**进阶** :  
如果多次调用这个函数，你将如何优化你的算法？

 **[原题](https://leetcode-cn.com/problems/number-of-1-bits/)**    **[代码文件](https://github.com/LZH139/leetcode_Go/blob/master/src/BitManipulation/simple/NumberOf1Bits/NumberOf1Bits.go)**


### 参考文献
无

### 解题思路

我们可以把前面的算法进行优化。我们不再检查数字的每一个位，而是不断把数字最后一个 11 反转，并把答案加一。当数字变成 00 的时候偶，我们就知道它没有 11 的位了，此时返回答案。

这里关键的想法是对于任意数字 nn ，将 nn 和 n - 1n−1 做与运算，会把最后一个 11 的位变成 00 。为什么？考虑 nn 和 n - 1n−1 的二进制表示。

![abfd6109e7482d70d20cb8fc1d632f90eacf1b5e89dfecb2e523da1bcb562f66-image](https://tva1.sinaimg.cn/large/007S8ZIlgy1gdpogt98z0j30of0nd0tl.jpg)

图片 1. 将 nn 和 n-1n−1 做与运算会将最低位的 11 变成 00

在二进制表示中，数字 nn 中最低位的 11 总是对应 n - 1n−1 中的 00 。因此，将 nn 和 n - 1n−1 与运算总是能把 nn 中最低位的 11 变成 00 ，并保持其他位不变。

使用这个小技巧，代码变得非常简单。


### 参考代码

```go
func hammingWeight(num uint32) int {
    sum:=0
    for num != 0 {
        sum++
        num = num&(num-1)
    }
    return sum
}

```




