### 题目
给定一个整数数组，其中第 _  i_ 个元素代表了第  _i_  天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

  * 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
  * 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**示例:**


​    
    输入: [1,2,3,0,2]
    输出: 3 
    解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

 **[原题](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)**    **[代码文件]()**


### 参考文献
无

### 解题思路

**状态机思路：**

​		**我们将买卖股票的整个过程，总结出三个状态，而每个状态都有对应的动作，而买卖股票的过程就是由动作引发状态的转变的一个过程**

**易混点：**

最容易弄错的一点即是**状态和动作搞混**，很多人一开始的思路可能是犯了这样的一个问题(我一开始也是这样)。比方说，

* **休息的定义是，什么也不干，不买也不卖。**

* **冷冻期的定义是也是什么也不干。**

  

​         那有人可能会觉得，那冷冻期和休息一样，那我我是不是可以将休息当成一种状态和冷冻期合并？

​		于是状态方程就写错了。

​		那为什么休息和冷冻期不能合并作为一种状态，或者动作，毕竟看起来这两个好像一样？

​		其实我们只要抓住一点就可以区分清楚状态和动作了，就是**动作是一种行为，在这个问题上，动作都是作用在股票上的一种行为。**

​		**所以我们从股票的角度来看就很清楚了，我们可以对股票做买入这个动作，即是买入股票，同理，我们可以卖出股票，或者持有股票，即是休息。**

​		**当我们卖出股票后，我们的仓库就空了，随着我们做出了卖出股票的这个动作，我们的仓库变成空的了，这个就是仓库因为动作而发生改变了，那么空仓就是一个状态，同理其他也是如此**

​		**所以总结一下，我们只要抓住问题研究的对象，然后看我们能对这个对象做什么，这个即是动作，然后再看随着这些动作的发生，什么随之发生了改变，那么这个就是状态**

​		而比较多的题解在状态的形容上使用了不是那么容易理解的词汇，比方说空仓称为卖出股。满仓（之所以称为满仓，是因为作为题目的天选之子，难道不应该 all in 吗？)，称为持有股票。这在一定程度上会使初看的人把动作和状态混淆，在这里我使用了名词代表状态，动词代表动作，以方便区分。

**得出状态方程：**

那么在区分出状态和动作并将他们完整归纳出来后，我们就可以很容易的画出如下状态转变的过程。

![屏幕快照 2020-04-14 下午7.57.02](/Users/lzh/Desktop/屏幕快照 2020-04-14 下午7.57.02.png)

​	为了存储之前的状态，我们新建一个$$ 3*n $$的数组，其中$$ n $$为总天数。而$$3$$代表代表了每天可能处于的状态。数组中存储的是每天的每个状态中的收益。其中

​	`0` 代表空仓

​	`1` 代表满仓

​	`2` 代表冷冻期

* 如果当前为空仓状态，那么前一天可能是冷冻期状态，然后进行休息后到了今天的空仓状态，或者前一天是空仓，休息后依旧保持空仓，我们同样在这两者总选择收益最大

  `dp[i][0] = Max(dp[i-1][0],dp[i-1][2])`

* 如果当前为满仓状态，那么前一天可能为空仓，然后进行买入后变为了满仓，或者前一天依旧是满仓，在休息后保持满仓状态，那么在这两者中选择收益最大的。

  `dp[i][1] = Max(dp[i-1][0]-prices[i],dp[i-1][1])`

* 如果当前状态属于冷冻期，那么前一天只能为满仓状态，因为空仓无论经过什么动作都不会进入冷冻期，只有满仓状态，在卖出股票后才会变成冷冻期状态，所以有：

  ` dp[i][2] = dp[i-1][1]+prices[i]`

**设置初始条件：**

​	我们考虑第一天时，我们做的动作。

* 我们可以什么也不干，那么状态是空仓，此时`dp[0][0] = 0`

* 我们买入第一天的股票，即是满仓，此时 `dp[0][1] = -prices[0]`

* 我们处于冷冻期，但是第一天是不可能处于冷冻期，因为我们没有卖出股票，不过冷冻期状态中，我们什么也不能干，所以可以将这个初始状态设为0，

  即`dp[0][2] = 0`

**结束返回：**

​	考虑最后一天的情况，我们要想收益最大，那么最后一天的状态自然是卖出(获得收益)，或者是持有(保持盈利)，买入显然是不可能的，毕竟你没法卖出了，必定亏。

**分析到这里，那么我们可以很容易的写出下面的代码了。**




### 参考代码

```go
func maxProfit(prices []int) int {
    dp := make([][]int, len(prices)+1)

    days := len(prices)-1

    if len(prices) <2 {
        return 0
    }

    dp[0] = make([]int,3)
    //0->空仓 1—>满仓 2->冷冻期
    dp[0][0] = 0
    dp[0][1] = -prices[0]
    dp[0][2] = 0

    for i:=1;i<len(prices);i++ {
        dp[i] = make([]int,3)
        dp[i][0] = Max(dp[i-1][0],dp[i-1][2])
        dp[i][1] = Max(dp[i-1][0]-prices[i],dp[i-1][1])
        dp[i][2] = dp[i-1][1]+prices[i]
    }

    return Max(dp[days][0],dp[days][2])

}

func Max(x int,y int) int {
    if x>y {
        return x
    }
    return y
}

```




